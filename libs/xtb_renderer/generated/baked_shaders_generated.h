const char *test_vertex_source = ""
   "#version 330 core\n"
   "\n"
   "layout(location=0) in vec3 aPos;\n"
   "\n"
   "void main()\n"
   "{\n"
   "    gl_Position = vec4(aPos, 1.0);\n"
   "}\n";

const char *ortho_vertex_source = ""
   "#version 330 core\n"
   "layout (location = 0) in vec2 aPos;\n"
   "\n"
   "uniform mat4 projection;\n"
   "\n"
   "void main()\n"
   "{\n"
   "    gl_Position = projection * vec4(aPos, 0.0, 1.0);\n"
   "}\n";

const char *voronoi_fragment_source = ""
   "#version 330 core\n"
   "\n"
   "#define POINTS_COUNT 30\n"
   "#define PALETTE_SEED 34\n"
   "#define POSITION_SEED 13\n"
   "#define BLUR 0.3\n"
   "#define FRAME_PADDING 0.01\n"
   "#define SPEED 0.2\n"
   "\n"
   "uniform float iTime;\n"
   "uniform vec2 iResolution;\n"
   "\n"
   "in vec2 texCoords;\n"
   "in vec3 position;\n"
   "in vec3 localPosition;\n"
   "in vec3 normal;\n"
   "\n"
   "out vec4 fragColor;\n"
   "\n"
   "struct TriplanarUV\n"
   "{\n"
   "    vec2 x;\n"
   "    vec2 y;\n"
   "    vec2 z;\n"
   "};\n"
   "\n"
   "TriplanarUV GetTriplanarUV(vec3 pos)\n"
   "{\n"
   "    pos = fract(abs(pos));\n"
   "\n"
   "    TriplanarUV triUV;\n"
   "    triUV.x = pos.zy;\n"
   "    triUV.y = pos.xz;\n"
   "    triUV.z = pos.xy;\n"
   "    return triUV;\n"
   "}\n"
   "\n"
   "vec3 GetTriplanarWeights(vec3 normal)\n"
   "{\n"
   "    vec3 blendWeights = abs(normal) - 0.2;\n"
   "    blendWeights *= 7.0;\n"
   "    blendWeights = pow(blendWeights, vec3(3.0));\n"
   "    blendWeights = max(blendWeights, 0.0);\n"
   "    blendWeights /= dot(blendWeights, vec3(1.0));\n"
   "    return blendWeights;\n"
   "}\n"
   "\n"
   "float Random(float x)\n"
   "{\n"
   "    return fract(sin(x * 12.9898) * 43758.5453);\n"
   "}\n"
   "\n"
   "float LinearNoise1d(float x)\n"
   "{\n"
   "    return mix(Random(floor(x)), Random(floor(x) + 1.), fract(x));\n"
   "}\n"
   "\n"
   "float Remap(float i1, float i2, float o1, float o2, float x)\n"
   "{\n"
   "    return o1 + (x - i1) / (i2 - i1) * (o2 - o1);\n"
   "}\n"
   "\n"
   "struct PointInfo\n"
   "{\n"
   "    float dist;\n"
   "    vec3 col;\n"
   "};\n"
   "\n"
   "vec3 GetVoronoiColor(vec2 uv, float aspectRatio)\n"
   "{\n"
   "    PointInfo info[POINTS_COUNT];\n"
   "    float minDist = 10000.;\n"
   "\n"
   "    for (int i = 0; i < POINTS_COUNT; i++)\n"
   "    {\n"
   "        float x = Random(float(i) + float(POSITION_SEED) * 534.) * aspectRatio;\n"
   "        float y = Random(float(i) + float(POSITION_SEED) * 123.);\n"
   "\n"
   "        float t = iTime * SPEED;\n"
   "        t *= Remap(0., 1., .9, 1., Random(float(i) * 12.5125));\n"
   "        float dx = Remap(0., 1., -x + FRAME_PADDING, -x + aspectRatio - FRAME_PADDING, LinearNoise1d(float(i) * 43. + t));\n"
   "        float dy = Remap(0., 1., -y + FRAME_PADDING, -y + 1. - FRAME_PADDING, LinearNoise1d(float(i) * 261. + t));\n"
   "\n"
   "        x += dx;\n"
   "        y += dy;\n"
   "\n"
   "        float dist = length(uv - vec2(x, y));\n"
   "\n"
   "        float r = Random(float(i) * float(PALETTE_SEED) + 0.);\n"
   "        float g = Random(float(i) * float(PALETTE_SEED) + 100.);\n"
   "        float b = Random(float(i) * float(PALETTE_SEED) + 200.);\n"
   "\n"
   "        info[i].dist = dist;\n"
   "        info[i].col = vec3(r, g, b);\n"
   "\n"
   "        if (minDist > dist)\n"
   "        {\n"
   "            minDist = dist;\n"
   "        }\n"
   "    }\n"
   "\n"
   "    vec3 col = vec3(0.);\n"
   "\n"
   "    for (int i = 0; i < POINTS_COUNT; i++)\n"
   "    {\n"
   "        float c = smoothstep(minDist + BLUR, minDist, info[i].dist);\n"
   "        col = mix(col, info[i].col, c);\n"
   "    }\n"
   "\n"
   "    return col;\n"
   "}\n"
   "\n"
   "void main()\n"
   "{\n"
   "    vec2 uv = texCoords;;\n"
   "    float aspectRatio = iResolution.x / iResolution.y;\n"
   "    uv.x *= aspectRatio;\n"
   "\n"
   "    TriplanarUV triUV = GetTriplanarUV(localPosition * 2.0);\n"
   "    vec3 weights = GetTriplanarWeights(normal);\n"
   "\n"
   "    vec3 albedoX = GetVoronoiColor(triUV.x, aspectRatio);\n"
   "    vec3 albedoY = GetVoronoiColor(triUV.y, aspectRatio);\n"
   "    vec3 albedoZ = GetVoronoiColor(triUV.z, aspectRatio);\n"
   "\n"
   "    vec3 col = weights.x * albedoX + weights.y * albedoY + weights.z * albedoZ;\n"
   "\n"
   "    fragColor = vec4(col, 1.0);\n"
   "}\n";

const char *solid_color_fragment_source = ""
   "#version 330 core\n"
   "out vec4 FragColor;\n"
   "\n"
   "uniform vec4 color;\n"
   "\n"
   "void main()\n"
   "{\n"
   "    FragColor = color;\n"
   "}\n";

const char *polyline_2d_instanced_vertex_source = ""
   "#version 330 core\n"
   "\n"
   "// Per vertex data\n"
   "layout (location = 0) in float t;\n"
   "layout (location = 1) in float side;\n"
   "\n"
   "// Instanced data\n"
   "layout (location = 2) in vec2 aPrev;\n"
   "layout (location = 3) in vec2 aCurrentStart;\n"
   "layout (location = 4) in vec2 aCurrentEnd;\n"
   "layout (location = 5) in vec2 aNext;\n"
   "\n"
   "uniform mat4 uProjection;\n"
   "uniform float uThickness;\n"
   "\n"
   "struct MiterData\n"
   "{\n"
   "    vec2 miter;\n"
   "    float length;\n"
   "};\n"
   "\n"
   "MiterData compute_miter(vec2 prev, vec2 current, vec2 next)\n"
   "{\n"
   "    vec2 dir_a = normalize(current - prev);\n"
   "    vec2 dir_b = normalize(next - current);\n"
   "\n"
   "    if (length(next - current) < 1e-5)\n"
   "        dir_b = dir_a;\n"
   "    if (length(current - prev) < 1e-5)\n"
   "        dir_a = dir_b;\n"
   "\n"
   "    vec2 normal_a = vec2(-dir_a.y, dir_a.x);\n"
   "    vec2 normal_b = vec2(-dir_b.y, dir_b.x);\n"
   "    vec2 tangent = normalize(dir_a + dir_b);\n"
   "\n"
   "    vec2 miter = vec2(-tangent.y, tangent.x);\n"
   "    float miter_len = 1.0f / dot(miter, normal_a);\n"
   "\n"
   "    MiterData mdata;\n"
   "    mdata.miter = miter;\n"
   "    mdata.length = miter_len;\n"
   "    return mdata;\n"
   "}\n"
   "\n"
   "void main()\n"
   "{\n"
   "    float halfWidth = uThickness * 0.5;\n"
   "    vec2 dir = aCurrentEnd - aCurrentStart;\n"
   "    vec2 normal = normalize(vec2(-dir.y, dir.x));\n"
   "\n"
   "    vec2 miterOffset;\n"
   "    if (t < 0.5)\n"
   "    {\n"
   "        MiterData miterA = compute_miter(aPrev, aCurrentStart, aCurrentEnd);\n"
   "        miterOffset = miterA.miter * (miterA.length * halfWidth);\n"
   "    }\n"
   "    else\n"
   "    {\n"
   "        MiterData miterB = compute_miter(aCurrentStart, aCurrentEnd, aNext);\n"
   "        miterOffset = miterB.miter * (miterB.length * halfWidth);\n"
   "    }\n"
   "\n"
   "    vec2 selectedSegmentEnd = (1.0 - t) * aCurrentStart + t * aCurrentEnd;\n"
   "    vec2 position = selectedSegmentEnd + (side * miterOffset);\n"
   "\n"
   "    gl_Position = uProjection * vec4(position, 0.0, 1.0);\n"
   "}\n";

const char *texture_fragment_source = ""
   "#version 330 core\n"
   "out vec4 FragColor;\n"
   "\n"
   "in vec2 texCoords;\n"
   "in vec3 normal;\n"
   "in vec3 position;\n"
   "\n"
   "uniform sampler2D tex;\n"
   "uniform vec3 u_LightPosition;\n"
   "uniform vec3 u_LightColor;\n"
   "\n"
   "void main()\n"
   "{\n"
   "    float ambientStrength = 0.1;\n"
   "    vec3 ambient = ambientStrength * u_LightColor;\n"
   "\n"
   "    vec3 lightDirection = normalize(u_LightPosition - position);\n"
   "    vec3 norm = normalize(normal);\n"
   "\n"
   "    float diffuseStrength = clamp(dot(norm, lightDirection), 0.0, 1.0);\n"
   "    vec3 diffuse = diffuseStrength * u_LightColor;\n"
   "\n"
   "    vec3 objColor = texture(tex, texCoords).xyz;\n"
   "    vec3 shadedColor = (ambient + diffuse) * objColor;\n"
   "\n"
   "    FragColor = vec4(shadedColor, 1.0);\n"
   "}\n";

const char *test_fragment_source = ""
   "#version 330 core\n"
   "\n"
   "out vec4 FragColor;\n"
   "\n"
   "void main()\n"
   "{\n"
   "    FragColor = vec4(vec3(1.0, 0.0, 0.0), 1.0);\n"
   "}\n";

const char *mvp_vertex_source = ""
   "#version 330 core\n"
   "layout (location = 0) in vec3 aPos;\n"
   "layout (location = 1) in vec3 aNormal;\n"
   "layout (location = 2) in vec2 aTexCoords;\n"
   "\n"
   "uniform mat4 model;\n"
   "uniform mat4 view;\n"
   "uniform mat4 projection;\n"
   "\n"
   "out vec2 texCoords;\n"
   "out vec3 position;\n"
   "out vec3 localPosition;\n"
   "out vec3 normal;\n"
   "\n"
   "void main()\n"
   "{\n"
   "    vec4 worldCoords = model * vec4(aPos, 1.0);\n"
   "    gl_Position = projection * view * worldCoords;\n"
   "    texCoords = aTexCoords;\n"
   "\n"
   "    position = vec3(worldCoords);\n"
   "    localPosition = aPos;\n"
   "\n"
   "    normal = inverse(transpose(mat3(model))) * aNormal;\n"
   "}\n";

